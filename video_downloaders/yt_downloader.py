import subprocess
from video_downloaders.video_downloader import VideoDownloader
import os
import json
from enum import Enum
from archive_api import ArchiveAPI

class VideoType(Enum):
    VIDEO = 1
    PLAYLIST = 2


class YouTubeDownloader(VideoDownloader):
    """
    A class that downloads YouTube videos using yt-dlp
    """
    def __init__(
        self,
        output_dir: str,
        log_skip_file: str = "logs/skipped.txt",
        log_deleted_file: str = "logs/deleted.txt",
        cookies_file: str = "cookies.txt",
    ):
        """
        Creates a new YouTubeDownloader object
        :param output_dir: str - The directory to output the downloaded videos to
        :param log_skip_file: str - The file to log skipped videos to
        :param log_deleted_file: str - The file to log deleted videos to
        """
        super().__init__(output_dir, log_skip_file, log_deleted_file)
        self.cookies = cookies_file

    def _get_video_id(self, video_url: str) -> str:
        """
        Tries multiple methods to get the video ID from a YouTube URL
        Also works to get the playlist ID from a YouTube playlist URL
        :param video_url: str
        :return: str
        """
        if "youtube.com" in video_url:
            return video_url.split("=")[1]
        elif "youtu.be" in video_url:
            return video_url.split("/")[-1]

    def identify_url_type(self, video_url: str) -> str:
        """
        Checks if the URL is a Video or a Playlist
        """
        if "playlist" in video_url:
            return VideoType.PLAYLIST # For future use stub for now
        else:
            return VideoType.VIDEO


    def download_video(self, video_url: str) -> tuple:
        """
        Downloads a video. Returns the file extension of the downloaded video
        """
        self._write_debug_log(f"Downloading video using yt-dlp {video_url}")
        result = subprocess.run(
            f'yt-dlp "{video_url}" -f "bestvideo[height<=1080][ext=webm]+bestaudio" -o "{self._output_dir}/video/%(id)s.%(ext)s" --cookies {self.cookies} --add-metadata',
            shell=True,
        )

        video_id = self._get_video_id(video_url)
        video_path = f"{self._output_dir}/video/{video_id}.webm"
        file_ext = "webm"

        if result.returncode != 0 or not os.path.exists(video_path):
            self._write_debug_log(f"WebM download failed for {video_url}, attempting MP4 download")
            result = subprocess.run(
                f'yt-dlp "{video_url}" -o "{self._output_dir}/video/%(id)s.%(ext)s" --add-metadata --cookies {self.cookies}',
                shell=True,
            )
            video_path = f"{self._output_dir}/video/{video_id}.mp4"
            file_ext = "mp4" if result.returncode == 0 and os.path.exists(video_path) else None

        file_size = os.path.getsize(video_path)
        if os.path.exists(video_path) and file_size > self._max_file_size_bytes:
            self._write_debug_log(f"Video {video_url} exceeds max file size. Deleting...")
            self._write_to_log_deleted(video_url)
            os.remove(video_path)
            return None,0
        return file_ext, round(file_size/(1024*1024), 2)


    def download_thumbnail(self, video_url: str):
        self._write_debug_log(f"Downloading thumbnail using yt-dlp {video_url}")
        subprocess.run(
            f'yt-dlp "{video_url}" --write-thumbnail --skip-download --convert-thumbnails jpg -o "{self._output_dir}/thumbnail/%(id)s.%(ext)s" --cookies {self.cookies}',
            shell=True,
        )


    def download_captions(self, video_url: str):
        def get_non_autogenerated_subs(url):
            self._write_debug_log(f"Getting non-autogenerated subtitles using yt-dlp {video_url}")
            try:
                output = subprocess.check_output(['yt-dlp', '--list-subs', url, "--cookies", self.cookies], stderr=subprocess.STDOUT)
            except subprocess.CalledProcessError as e:
                output = e.output
            output = output.decode('utf-8')
            output = output.split('\n')
            lines = []
            delete_line = False
            for line in output:
                if line.startswith('[info]'):
                    if delete_line:
                        delete_line = False
                    else:
                        delete_line = True
                if not delete_line:
                    lines.append(line)
            output = lines
            subtitle_formats = [line.split()[0] for line in output if "srv3" in line]
            self._write_debug_log(f"Found subtitle formats {subtitle_formats}")
            return subtitle_formats

        def download_subs(url, subs, video_id):
            self._write_debug_log(f"Starting to download captions (srv3) for {url}")
            if len(subs) == 0:
                self._write_debug_log(f"No captions found for {url}")
                return
            for sub in subs:
                self._write_debug_log(f"Now Downloading {sub} captions")
                try:
                    subprocess.check_output(['yt-dlp', '--sub-format', 'srv3', '--sub-lang', sub, '--write-sub',
                                            '--skip-download', '--output', self._output_dir+"/"+"captions/"+
                                            video_id+'/%(id)s' +'.%(ext)s', url, '--cookies', self.cookies], universal_newlines=True)
                except subprocess.CalledProcessError as e:
                    self._write_debug_log(f'!!!!! Error downloading subtitle: {e.output} !!!!!')

        def rename_subtitles(subtitles, video_id):
            self._write_debug_log(f"Renaming subtitles for {video_id}")
            for subtitle in subtitles:
                old_name = video_id + '.' + subtitle[0] + '.srv3'
                new_name = video_id + '.' + subtitle[0] + '.srv3'
                if os.path.exists(old_name):
                    os.rename(old_name, new_name)

        self._write_debug_log(f"Downloading captions using yt-dlp {video_url}")
        video_id = self._get_video_id(video_url)
        if not os.path.exists(f"{self._output_dir}/captions/{video_id}"):
            os.makedirs(f"{self._output_dir}/captions/{video_id}")
        subtitles = get_non_autogenerated_subs(video_url)
        download_subs(video_url, subtitles, video_id)
        rename_subtitles(subtitles, video_id)


    def download_metadata(self, video_url: str) -> dict:
        """
        Metadata considered as .info.json file
        Returns a dictionary of certain key-value pairs for backup DB
        """
        def format_description_escape_char(description):
            """
            Formats the description newlines to escape characters
            """
            return description.replace("\n", " \\n")

        self._write_debug_log(f"Downloading metadata (.info.json) using yt-dlp {video_url}")
        subprocess.run(
            f'yt-dlp --write-info-json -o "output/metadata/%(id)s.%(ext)s" --skip-download {video_url} --cookies {self.cookies}',
            shell=True,
        )
        video_obj = json.loads(open(f"output/metadata/{self._get_video_id(video_url)}.info.json", "r", encoding="utf-8").read())
        description = format_description_escape_char(video_obj["description"])
        vid_date = video_obj["upload_date"]
        vid_date = f"{vid_date[:4]}-{vid_date[4:6]}-{vid_date[6:]}"
        return {
            "video_id": video_obj["id"],
            "title": video_obj["title"],
            "channel_id": video_obj["channel_id"],
            "uploader": video_obj["uploader"],
            "upload_date": vid_date,
            "description": description,
            "channel_name": video_obj["channel"],
        }
