import subprocess
from archive_api import ArchiveAPI
from video_downloaders.video_downloader import VideoDownloader
import os
import json


class YouTubeDownloader(VideoDownloader):
    """
    A class that downloads YouTube videos using yt-dlp
    """
    def __init__(
        self,
        output_dir: str,
        log_skip_file: str = "logs/skipped.txt",
        log_deleted_file: str = "logs/deleted.txt",
    ):
        """
        Creates a new YouTubeDownloader object
        :param output_dir: str - The directory to output the downloaded videos to
        :param log_skip_file: str - The file to log skipped videos to
        :param log_deleted_file: str - The file to log deleted videos to
        """
        super().__init__(output_dir, log_skip_file, log_deleted_file)
    
    def download_video(self, video_url: str, file_type:str):
        self._write_debug_log(f"Downloading video using yt-dlp {video_url}")
        subprocess.run(
            f'yt-dlp "{video_url}" -f "bestvideo[height<=1080][ext=webm]+bestaudio" -o "{self._output_dir}/video/%(id)s.%(ext)s" --add-metadata',
            shell=True,
        )
        if os.path.getsize(f"{self._output_dir}/video/{video_url.split('=')[1]}.webm") > self._max_file_size_bytes:
            self._write_debug_log(f"Video {video_url} exceeds max file size. Deleting...")
            self._write_to_log_deleted(video_url)
            os.remove(f"{self._output_dir}/video/{video_url.split('=')[1]}.webm")
            return


    def download_thumbnail(self, video_url: str):
        self._write_debug_log(f"Downloading thumbnail using yt-dlp {video_url}")
        subprocess.run(
            f'yt-dlp "{video_url}" --write-thumbnail --skip-download --convert-thumbnails jpg -o "{self._output_dir}/thumbnail/%(id)s.%(ext)s"',
            shell=True,
        )


    def download_captions(self, video_url: str): # stub for now
        def get_non_autogenerated_subs(url):
            self._write_debug_log(f"Getting non-autogenerated subtitles using yt-dlp {video_url}")
            try:
                output = subprocess.check_output(['yt-dlp', '--list-subs', url], stderr=subprocess.STDOUT)
            except subprocess.CalledProcessError as e:
                output = e.output
            output = output.decode('utf-8')
            output = output.split('\n')
            lines = []
            delete_line = False
            for line in output:
                if line.startswith('[info]'):
                    if delete_line:
                        delete_line = False
                    else:
                        delete_line = True
                if not delete_line:
                    lines.append(line)
            output = lines
            subtitle_formats = [line.split()[0] for line in output if "srv3" in line]
            self._write_debug_log(f"Found subtitle formats {subtitle_formats}")
            return subtitle_formats
        
        def download_subs(url, subs, video_id):
            self._write_debug_log(f"Starting to download captions (srv3) for {url}")
            if len(subs) == 0:
                self._write_debug_log(f"No captions found for {url}")
                return
            for sub in subs:
                self._write_debug_log(f"Now Downloading {sub} captions")
                try:
                    subprocess.check_output(['yt-dlp', '--sub-format', 'srv3', '--sub-lang', sub, '--write-sub',
                                            '--skip-download', '--output', self._output_dir+"/"+"captions/"+
                                            video_id+'/%(id)s' +'.%(ext)s', url], universal_newlines=True)
                except subprocess.CalledProcessError as e:
                    self._write_debug_log(f'!!!!! Error downloading subtitle: {e.output} !!!!!')

        def rename_subtitles(subtitles, video_id):
            self._write_debug_log(f"Renaming subtitles for {video_id}")
            for subtitle in subtitles:
                old_name = video_id + '.' + subtitle[0] + '.srv3'
                new_name = video_id + '.' + subtitle[0] + '.srv3'
                if os.path.exists(old_name):
                    os.rename(old_name, new_name)

        self._write_debug_log(f"Downloading captions using yt-dlp {video_url}")
        video_id = video_url.split('=')[1]
        if not os.path.exists(f"{self._output_dir}/captions/{video_id}"):
            os.makedirs(f"{self._output_dir}/captions/{video_id}")
        subtitles = get_non_autogenerated_subs(video_url)
        download_subs(video_url, subtitles, video_id)
        rename_subtitles(subtitles, video_id)



    def download_metadata(self, video_url: str) -> dict:
        """
        Metadata considered as .info.json file
        Returns a dictionary of certain key-value pairs for backup DB
        """
        def format_description_escape_char(description):
            """
            Formats the description newlines to escape characters
            """
            return description.replace("\n", " \\n")
        
        self._write_debug_log(f"Downloading metadata (.info.json) using yt-dlp {video_url}")
        subprocess.run(
            f'yt-dlp --write-info-json -o "output/metadata/%(id)s.%(ext)s" --skip-download {video_url}',
            shell=True,
        )
        video_obj = json.loads(open(f"output/metadata/{video_url.split('=')[1]}.info.json", "r", encoding="utf-8").read())
        description = format_description_escape_char(video_obj["description"])
        vid_date = video_obj["upload_date"]
        vid_date = f"{vid_date[:4]}-{vid_date[4:6]}-{vid_date[6:]}"
        return {
            "video_id": video_obj["id"],
            "title": video_obj["title"],
            "channel_id": video_obj["channel_id"],
            "uploader": video_obj["uploader"],
            "upload_date": vid_date,
            "description": description,
            "channel_name": video_obj["channel"],
        }


    


